{"meta":{"title":"Kirbey's blog","subtitle":"自我学习的博客页面","description":null,"author":"kirbey","url":"https://kirbey.github.io/hexoBlog","root":"/hexoBlog/"},"pages":[{"title":"测试","date":"2019-10-07T17:31:33.000Z","updated":"2019-10-07T17:31:33.194Z","comments":true,"path":"测试/index.html","permalink":"https://kirbey.github.io/hexoBlog/测试/index.html","excerpt":"","text":""}],"posts":[{"title":"ES6常用语法","slug":"ES6常用语法","date":"2019-10-18T07:38:41.000Z","updated":"2019-10-18T08:00:52.569Z","comments":true,"path":"2019/10/18/ES6常用语法/","link":"","permalink":"https://kirbey.github.io/hexoBlog/2019/10/18/ES6常用语法/","excerpt":"","text":"字符串扩展常用的一些方法 at() 1234// 参数传入角标，返回值为角标对应的字符&apos;abc&apos;.at(0) // &apos;a&apos;&apos;吉&apos;.at(0) // &apos;吉&apos;// 与ES5中charAt()不同之处，汉字的话ES5会返回对应Unicode编码，js内部用UTF-16 includes(),startsWith(),endsWith()·includes(),返回值为布尔值，表示能否找到参数的字符串·startsWith(),返回值为布尔值，表示参数字符串是否在原字符串的头部·endsWith(),返回布尔值，表示参数字符串是否在原字符串的尾部·这三个方法都支持第二个参数，表示开始搜索的位置。endsWith的行为与其他两个方法有所不同。它针对前N个字符，而其他两个方法针对从第n个位置直到字符串结束。 1234567let str = &apos;Hello World&apos;str.includes(&apos;Hello&apos;) // truestr.startsWith(&apos;Hello&apos;) // truestr.endsWith(&apos;d&apos;) // truestr.startsWith(&apos;world&apos;, 6) // truestr.endsWith(&apos;Hello&apos;, 5) // truestr.includes(&apos;Hello&apos;, 6) // false repeat() 1&apos;x&apos;.repeat(3) // &quot;xxx&quot; ·注意：参数不能传负数和infinity，参数NaN为0，参数为字符串会先转换为数字4. padStart(),padEnd()·参数两个，第一个为位数，第二个是用什么补全，省略第二个参数时默认为空格补全。这两个更多的用途是补全指定位数 123&apos;1&apos;.padStart(10, &apos;0&apos;) // &quot;0000000001&quot;&apos;12&apos;.padStart(10, &apos;0&apos;) // &quot;0000000012&quot;&apos;123456&apos;.padStart(10, &apos;0&apos;) // &quot;0000123456&quot; #数组拓展1.Array.from()Array.from方法用于将两类对象转为真正的数组：类似数组的对象(array-like object)和可遍历(iterable)的对象(包括ES6新增的数据结构Set和Map)2. …运算符拓展运算符(spread)是三个点(…)。它好比rest参数的逆运算，将一个数组转为用逗号分隔的参数序列。 12345console.log(...[1, 2, 3])// 1 2 3console.log(1, ...[2, 3, 4], 5)// 1 2 3 4 5 ·关于函数传参的问题，如果函数直接用…传参，传入的参数实际上是一个数组，且后面不能再有参数。如果函数参数定义了一个数组，用…传入，实际上参数为数值中的值。 12345678function fn(...items)&#123;&#125;//等同于function fn([数组内容])&#123;&#125;let items = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]function fn(...items)&#123;&#125;// 等同于function fn(&apos;a&apos;, &apos;b&apos;, &apos;c&apos;) &#123;&#125; …运算符的运用·复制数组（克隆数组）12let arr1 = [1, 2, 3]let arr2 = [...arr1] // [1, 2, 3] ·合并数组 12345const arr1 = [&apos;a&apos;, &apos;b&apos;]const arr2 = [&apos;c&apos;]const arr3 = [&apos;d&apos;, &apos;e&apos;]const arr4 = [...arr1, ...arr2, ...arr3] // [ &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos; ]·与解构赋值结合 const [first, …rest] = [1, 2, 3, 4, 5];first // 1rest // [2, 3, 4, 5] 1·将字符串转换为真正的数组 […’hello’]// [ “h”, “e”, “l”, “l”, “o” ] 4. 数组实例的fill()","categories":[{"name":"前端","slug":"前端","permalink":"https://kirbey.github.io/hexoBlog/categories/前端/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://kirbey.github.io/hexoBlog/tags/javaScript/"}]},{"title":"入门vuex（vue状态管理）","slug":"入门vuex（vue状态管理）","date":"2019-10-16T01:47:00.000Z","updated":"2019-10-16T02:20:43.850Z","comments":true,"path":"2019/10/16/入门vuex（vue状态管理）/","link":"","permalink":"https://kirbey.github.io/hexoBlog/2019/10/16/入门vuex（vue状态管理）/","excerpt":"","text":"#Vuex 是什么？Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 Vue 的官方调试工具 devtools extension，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。 #什么是“状态管理模式”？让我们从一个简单的 Vue 计数应用开始： 123456789101112131415161718new Vue(&#123; // state data () &#123; return &#123; count: 0 &#125; &#125;, // view template: ` &lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt; `, // actions methods: &#123; increment () &#123; this.count++ &#125; &#125;&#125;) 这个状态自管理应用包含以下几个部分： *state，驱动应用的数据源；*view，以声明方式将 state 映射到视图；*actions，响应在 view 上的用户输入导致的状态变化。以下是一个表示“单向数据流”理念的简单示意： 但是，当我们的应用遇到多个组件共享状态时，单向数据流的简洁性很容易被破坏：*多个视图依赖于同一状态。*来自不同视图的行为需要变更同一状态。对于问题一，传参的方法对于多层嵌套的组件将会非常繁琐，并且对于兄弟组件间的状态传递无能为力。对于问题二，我们经常会采用父子组件直接引用或者通过事件来变更和同步状态的多份拷贝。以上的这些模式非常脆弱，通常会导致无法维护的代码。 因此，我们为什么不把组件的共享状态抽取出来，以一个全局单例模式管理呢？在这种模式下，我们的组件树构成了一个巨大的“视图”，不管在树的哪个位置，任何组件都能获取状态或者触发行为！ 通过定义和隔离状态管理中的各种概念并通过强制规则维持视图和状态间的独立性，我们的代码将会变得更结构化且易维护。 这就是 Vuex 背后的基本思想，借鉴了 Flux、Redux 和 The Elm Architecture。与其他模式不同的是，Vuex 是专门为 Vue.js 设计的状态管理库，以利用 Vue.js 的细粒度数据响应机制来进行高效的状态更新。","categories":[{"name":"前端","slug":"前端","permalink":"https://kirbey.github.io/hexoBlog/categories/前端/"}],"tags":[{"name":"vuex","slug":"vuex","permalink":"https://kirbey.github.io/hexoBlog/tags/vuex/"}]},{"title":"AJAX","slug":"AJAX","date":"2019-10-10T15:42:59.000Z","updated":"2019-10-10T15:54:43.709Z","comments":true,"path":"2019/10/10/AJAX/","link":"","permalink":"https://kirbey.github.io/hexoBlog/2019/10/10/AJAX/","excerpt":"AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。 AJAX 不是新的编程语言，而是一种使用现有标准的新方法。 AJAX最大的优点是，在不重新加载整个页面的情况下，可以与服务器交换数据并更新部分网页内容。 AJAX不需要任何浏览器插件，但需要用户允许JavaScript在浏览器上执行。","text":"AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。 AJAX 不是新的编程语言，而是一种使用现有标准的新方法。 AJAX最大的优点是，在不重新加载整个页面的情况下，可以与服务器交换数据并更新部分网页内容。 AJAX不需要任何浏览器插件，但需要用户允许JavaScript在浏览器上执行。 AJAX应用： 运用XHTML+CSS来表达资讯； 运用javaScript操作DOM来执行动态效果； 运用XML和XSLT来操作资料； 运用XMLHttpRequest或新的Fetch API与网页服务器进行异步资料交换； 注意：AJAX与Flash、Silverlight和Java Applet等RIA技术是有区分的。 什么是AJAX： AJAX = 异步javaScript和XML。 AJAX是一种用于创建快速动态网页的技术。 通过在后台与服务器进行少量数据交换，AJAX可以使网页实现异步更新。只意味着可以在不重新加载这个网页的情况下，对网页的部分进行更新。 传统的网页要实现更新必须重新加载整个页面。 有很多使用AJAX的应用程序案例，渣浪，google地图，开心网等。 AJAX工作原理： AJAX使基于现有的internet标准 并且联合使用它们： XMLHttpRequest对象（异步的服务器交换数据）； javaScript/DOM（信息显示/交互）； CSS（给数据定义样式）； XML（作为转换数据的格式）； Google Suggest在 2005 年，Google 通过其 Google Suggest 使 AJAX 变得流行起来。 Google Suggest 使用 AJAX 创造出动态性极强的 web 界面：当您在谷歌的搜索框输入关键字时，JavaScript 会把这些字符发送到服务器，然后服务器会返回一个搜索建议的列表。 XMLHttpRequest对象 所有现代浏览器均支持XMLHttpRequest对象。 XMLHttpRequest用于在后台与服务器交换数据，这意味着再不用加载整个页面的情况下，对王爷的部分进行更新。 创建XMLHttpRequest对象 所有现代浏览器均内建XMLHttprequest对象 创建XMLHttpRequest对象的语法： 1var iable=new XMLHttpRequest(); 实例： 1234567891011var xmlhttp;if (window.XMLHttpRequest)&#123; // IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码 xmlhttp=new XMLHttpRequest();&#125;else&#123; // IE6, IE5 浏览器执行代码 xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);&#125; 向服务器发送请求： 如需将请求发送到服务器，我们使用XMLHttpRequest对象的open（）和send（）方法： 12xmlhttp.open(&quot;GET&quot;,&quot;ajax_info.txt&quot;,true);xmlhttp.send(); GET还是POST 与POST相比GET更快也更简单，并且在大部分情况下都能用。 然而，在以下情况中请使用POST请求： 无法使用缓存文件（更新服务器上的数据或文件库） 向服务器发送大量数据（POST没有数据量限制） 发送包含未知字符的用户输入时，POST也比GET更可靠。 GET请求 一个简单的GET请求： 12xmlhttp.open(&quot;GET&quot;,&quot;/try/ajax/demo_get.php&quot;,true);xmlhttp.send(); 在上面的例子中你可能得到的时缓存的结果。 为了避免这种情况请向URL添加一个唯一的ID: 12xmlhttp.open(&quot;GET&quot;,&quot;/try/ajax/demo_get.php?t=&quot; + Math.random(),true);xmlhttp.send(); 如果你希望通过GET请求向服务器发送信息请向URL添加信息： 12xmlhttp.open(&quot;GET&quot;,&quot;/try/ajax/demo_get2.php?fname=Henry&amp;lname=Ford&quot;,true);xmlhttp.send(); POET请求 一个简单的POST请求： 12xmlhttp.open(&quot;POST&quot;,&quot;/try/ajax/demo_post.php&quot;,true);xmlhttp.send(); 如果需要向HTML表单那样POST数据，请使用setRequestHeader（）来添加HTTP头，然后在send（）方法中规定您希望发送的数据： 123xmlhttp.open(&quot;POST&quot;,&quot;/try/ajax/demo_post2.php&quot;,true);xmlhttp.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);xmlhttp.send(&quot;fname=Henry&amp;lname=Ford&quot;); URL-服务器上的文件 open（）方法的url参数是服务器上文件的地址： xmlhttp.open(“GET”,”ajax_test.html”,true);该文件可以是任何类型的文件，比如txt或xml，或者服务器脚本文件，比如.asp或.php 异步ture或false？ AJAX指的是异步javaScript和XML。 XMLHttpRequest对象如果要用AJAX的话，其open（）方法的async参数必须设置为ture： xmlhttp.open(“GET”,”ajax_test.html”,true);位于web从业人员来叔发送异步请求是一个巨大的进步，很多在服务器执行的任务都相当费时。在AJAX出现之前这可能会导致应用程序挂起或停止。 通过AJAX，javaScript可以不用等待服务器的响应，而是： 在等待服务器响应时执行其他脚本。 当响应就绪后对其进行处理。 Async=ture 当使用async=ture时，请规定在响应处于onreadystatechange事件中的就绪状态时执行的函数： 12345678910xmlhttp.onreadystatechange=function()&#123; if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) &#123; document.getElementById(&quot;myDiv&quot;).innerHTML=xmlhttp.responseText; &#125;&#125;xmlhttp.open(&quot;GET&quot;,&quot;/try/ajax/ajax_info.txt&quot;,true);xmlhttp.send();Async=false 如果使用Async=false，请将open（）方法中的打三个参数设置为false： xmlhttp.open(“GET”,”test1.txt”,false);不推荐使用async=false，但是对一些小的请求也是可以的： 请记住，JavaScript 会等到服务器响应就绪才继续执行。如果服务器繁忙或缓慢，应用程序会挂起或停止。 注意：当您使用 async=false 时，请不要编写 onreadystatechange 函数 - 把代码放到 send() 语句后面即可。 AJAX-服务器响应 如需获取来自服务器的响应，请使用XMLHttpRequest对象的response Text或responseXML属性。 responseText属性 如果来自服务器的响应并非XML，请使用responseText属性。 responseText属性返回字符串形式的响应，因此可以这样使用： document.getElementById(“myDiv”).innerHTML=xmlhttp.responseText;responseXML属性 如果来自服务器的响应是XML，而且需要作为XML对象进行解析，使用responseXML属性 12345678xmlDoc=xmlhttp.responseXML;txt=&quot;&quot;;x=xmlDoc.getElementsByTagName(&quot;ARTIST&quot;);for (i=0;i&lt;x.length;i++)&#123; txt=txt + x[i].childNodes[0].nodeValue + &quot;&lt;br&gt;&quot;;&#125;document.getElementById(&quot;myDiv&quot;).innerHTML=txt; onreadystatechange事件 当请求被发送到服务器时，需要执行一些基于响应的任务。 每当readystate改变时，就会出发onreadystatechange事件。 ready state属性存有XMLHttpRequest的状态信息。 下面时XMLHttpRequest对象的三个重要属性： 在onreadystatechange事件中，我们规定当服务器响应已经做好被处理的准备时所执行的任务。 当readystate的值为4或状态码为200时，表示相应已就绪。 1234567xmlhttp.onreadystatechange=function()&#123; if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) &#123; document.getElementById(&quot;myDiv&quot;).innerHTML=xmlhttp.responseText; &#125;&#125; 注意：onreadystatechange 事件被触发 4 次（0 - 4）, 分别是： 0-1、1-2、2-3、3-4，对应着 readyState 的每个变化。 使用回调函数 回调函数是一种使用参数的形式传递给另一个函数的函数 如果你的网站上存在多个AJAX任务，那么你应该为创建XMLHttpRequest对象编写一个标准的函数，并为每个AJAX任务调用该函数。 该函数调用应包含URL已经发生onreadystatechange事件时执行的任务。 12345678910function myFunction()&#123; loadXMLDoc(&quot;/try/ajax/ajax_info.txt&quot;,function() &#123; if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) &#123; document.getElementById(&quot;myDiv&quot;).innerHTML=xmlhttp.responseText; &#125; &#125;);&#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://kirbey.github.io/hexoBlog/categories/前端/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://kirbey.github.io/hexoBlog/tags/javaScript/"}]},{"title":"vuex","slug":"vuex","date":"2019-10-08T14:49:45.000Z","updated":"2019-10-08T14:57:52.290Z","comments":true,"path":"2019/10/08/vuex/","link":"","permalink":"https://kirbey.github.io/hexoBlog/2019/10/08/vuex/","excerpt":"Vuex是一个专门为Vue.js应用程序开发的状态管理模式。它采用集中式储存管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的状态发生变化。Vuex也集成到Vue的官方调试工具devtools extension，提供了诸如零配置的time-travel调试，状态快照导入导出等高级调试功能。 什么是“状态管理模式”？ 让我们从一个简单的Vue计数应用开始。 这个状态自管理应用包含一下几个部分： ·state，驱动应用的数据源； ·view，以声明方式将state映射到视图； ·action，相应在view上的用户输入导致的变化。 以下是一个表示“单项数据流”理念的简单示意：","text":"Vuex是一个专门为Vue.js应用程序开发的状态管理模式。它采用集中式储存管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的状态发生变化。Vuex也集成到Vue的官方调试工具devtools extension，提供了诸如零配置的time-travel调试，状态快照导入导出等高级调试功能。 什么是“状态管理模式”？ 让我们从一个简单的Vue计数应用开始。 这个状态自管理应用包含一下几个部分： ·state，驱动应用的数据源； ·view，以声明方式将state映射到视图； ·action，相应在view上的用户输入导致的变化。 以下是一个表示“单项数据流”理念的简单示意： 但是，当我们的组件遇到多个组件共享状态时，单向数据流的简洁性很容易被破坏： ·多个视图依赖于同一状态。 ·来自不同视图的行为需要变更同一状态。 对于问题一，传参的方式对于多层嵌套的组件将会非常繁琐，并且对于兄弟组件间的状态传递无能为力。 对于问题二，我们经常会采用父子组件直接引用或者通过事件来变更和同步状态的多份拷贝。以上的这些模式非常脆弱，通常会导致无法维护的代码。 因此，为什么我们不把组件的共享状态抽取出来，以一个全局单例模式管理呢？在这种模式下，我们的组件树构成了一个巨大的“视图”，不管在树的哪个位置，任何组件都能获取行为或触发状态。 通过定义和隔离状态管理中的各种概念并通过强制规则维持视图和状态间的独立性，我们的代码将会变得更结构化和易维护。 这就是Vuex背后的基本思想，借鉴了Flux，和Redux和Elm Architecture。与其他模式不同的是，Vuex是专门为Vue.js设计的状态管理库，以利用Vue.js的细粒度数据响应机制来进行高效的状态更新。 什么情况下我应该使用Vuex？ Vuex可以帮助我们管理共享状态，并附带了更多的概念和框架。着需要对短期和长期效益进行权衡。 如果你不打算开发大型单页应用，使用Vuex可能是繁琐冗余的。确实如此如果你的应用够简单，你最好不要使用Vuex。一个简单的store模式就足够你所需了。但是，如果你需要构建一个中大型单页应用，你可能会考虑如何更好地在组件外部管理状态，Vuex将会成为自然而然的选择。 安装 直接下载/CDN引用： https://unpkg.com/vuex​unpkg.com unpkg.com 以上链接会一直指向npm上发布的最新版本。你也可以通过这样的方式来指定版本。 在Vue之后引入Vuex会进行自动安装： 12345678&lt;script src=&quot;/path/to/vue.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;/path/to/vuex.js&quot;&gt;&lt;/script&gt;npmnpm install vuex --saveYarmyarn add vuex 在一个模块化的打包系统中，你必须通过Vue.use()来安装Vuex 1234import Vue from &apos;vue&apos;import Vuex from &apos;vuex&apos;Vue.use(Vuex) 当使用全局script标签引入Vuex时，不需要以上安装过程。 Promise Vuex依赖Promise。如果你支持的浏览器并没有实现Promise那么你可以使用一个 polyfill 的库，例如es6-promise。 你可以通过CDN将其引入： 1&lt;script src=&quot;https://cdn.jsdelivr.net/npm/es6-promise@4/dist/es6-promise.auto.js&quot;&gt;&lt;/script&gt; 然后window.Promise会自动可用。 如果你喜欢使用诸如npm和yarn等包管理器，可以按照下列方式执行安装： npm install es6-promise –save # npmyarn add es6-promise # Yarn或者更进一步，将下列代码添加到你使用Vuex之前的一个地方。 import ‘es6-promise/auto’自己构建 如果需要使用dev分支下的最新版本，您可以直接从Github上克隆代码并自己构建。 1234git clone https://github.com/vuejs/vuex.git node_modules/vuexcd node_modules/vuexnpm installnpm run build","categories":[{"name":"前端","slug":"前端","permalink":"https://kirbey.github.io/hexoBlog/categories/前端/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://kirbey.github.io/hexoBlog/tags/Vue/"}]},{"title":"封装一个函数","slug":"封装一个函数","date":"2019-10-08T14:29:43.000Z","updated":"2019-10-08T14:49:23.263Z","comments":true,"path":"2019/10/08/封装一个函数/","link":"","permalink":"https://kirbey.github.io/hexoBlog/2019/10/08/封装一个函数/","excerpt":"为了更方便的理解jQuery，我们来尝试自己封装一个函数使其拥有jQuery的功能，从而理解jQuery的原理。 首先我们写一个简单的HTML 接下来我们需要用到一个函数，来给HTML标签中的div元素添加一个class","text":"为了更方便的理解jQuery，我们来尝试自己封装一个函数使其拥有jQuery的功能，从而理解jQuery的原理。 首先我们写一个简单的HTML 接下来我们需要用到一个函数，来给HTML标签中的div元素添加一个class 注意在使用forEach() API的时候 对象必须是一个数组或伪数组。因此在给这个函数传递参数的时候需要加上[]. 用来添加text Content。 用来判断参数的属性接着封装这个函数 然后我们就可以尝试去调用它了 这里给几个简单的CSS属性 接着调用效果如下 至此我们自己完成了封装一个API并能够调用它 完整代码如下 1234567891011121314151617181920212223242526272829303132window.jQuery =function(node)&#123; let nodes = &#123;&#125; if (typeof node === &apos;string&apos;)&#123; let allSiblings = document.querySelectorAll(node) for (let i=0; i&lt;allSiblings.length; i++)&#123; nodes[i] = allSiblings[i] &#125; nodes.length = allSiblings.length &#125;else if (node instanceof Node)&#123; nodes = &#123; 0: node, length: 1 &#125; &#125; nodes.addClass = function(classes)&#123; classes.forEach((value) =&gt; &#123; for( let i=0; i&lt;nodes.length; i++)&#123; nodes[i].classList.add(value) &#125; &#125;) &#125; nodes.setText = function(text)&#123; for(let i=0; i&lt;nodes.length; i++)&#123; nodes[i].textContent = text &#125; &#125; return nodes&#125;window.$ = jQueryvar $div = $(&apos;div&apos;)$div.addClass([&apos;blue&apos;])$div.setText([&apos;hello world&apos;])","categories":[{"name":"前端","slug":"前端","permalink":"https://kirbey.github.io/hexoBlog/categories/前端/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://kirbey.github.io/hexoBlog/tags/javaScript/"}]},{"title":"Box Model","slug":"Box Model","date":"2019-10-08T12:54:31.000Z","updated":"2019-10-08T14:27:19.489Z","comments":true,"path":"2019/10/08/Box Model/","link":"","permalink":"https://kirbey.github.io/hexoBlog/2019/10/08/Box Model/","excerpt":"","text":"首先理解什么是盒模型： 网页可以看成是由许多个盒子通过不同的堆积方式组成的一个仓库，网页上的每个HTML元素都被浏览器看成是一个个矩形的盒子，这个盒子由元素的内容，填充，边框，边界组成。默认边框背景色透明，默认看不到盒子：（图一） Margin(外边距) - 清除边框外的区域，外边距是透明的。Border(边框) - 围绕在内边距和内容外的边框。Padding(内边距) - 清除内容周围的区域，内边距是透明的。Content(内容) - 盒子的内容，显示文本和图像。那么两种盒子模型分别是什么呢： 一、W3C的标准盒子模型：（图二） 在标准盒子模型中，width指的是content的宽度 二、IE盒子模型：（图三） 在IE盒子模型中width指的是content+padding+border这三个部分的宽度。 由于W3C盒模型适用于所有的浏览器，因此我们都默认使用W3C的盒模型，我们常见的就是确保了页面是按照W3C的盒模型渲染的。 使用box-sizing切换盒模型： box-sizing: content-box 这个是W3C盒子模型 box-sizing: border-box 这个是IE盒子模型 默认box-sizing的属性是content-box","categories":[{"name":"前端","slug":"前端","permalink":"https://kirbey.github.io/hexoBlog/categories/前端/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://kirbey.github.io/hexoBlog/tags/CSS/"}]},{"title":"什么是'闭包'","slug":"闭包","date":"2019-10-08T03:39:10.000Z","updated":"2019-10-08T12:48:22.352Z","comments":true,"path":"2019/10/08/闭包/","link":"","permalink":"https://kirbey.github.io/hexoBlog/2019/10/08/闭包/","excerpt":"","text":"闭包的概念非常简单：闭包就是能够读取其他函数内部变量的函数。 闭包不止作为一个优化代码的重要途经（可以帮助我们省去大量重复的代码，使整篇代码看起来清晰明朗）同时也具备两个重要功能：1、保护函数内的变量安全2、在内存中维持一个变量。要理解这两点的具体含义首先我们要理解变量的作用域：当你在一个函数内部声明变量（即局部变量）时一定要用 var ，否则实际是在申明一个全局变量。通常我们是不能在函数的作用域之外调取函数内的局部变量的，但某些特殊情况下需要我们这么做。这时我们需要在函数内部再定义一个函数。 123456789function f1()&#123; var n=999; function f2()&#123; alert(n); // 999 &#125; &#125; 在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1就是不可见的。 基于此我们不难理解第一点，由于局部变量只能被闭包调用从而保证了它的安全性。而之所以闭包可以在内存中维持一个变量是因为垃圾回收机制（garbage collection）。闭包可以使变量保持在被调用状态不会被回收。 根据这两点特性，也有两点注意事项：1、由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。2、闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。","categories":[{"name":"前端","slug":"前端","permalink":"https://kirbey.github.io/hexoBlog/categories/前端/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://kirbey.github.io/hexoBlog/tags/javaScript/"}]},{"title":"我的第一篇博客","slug":"我的第一篇博客","date":"2019-10-07T17:57:28.000Z","updated":"2019-10-07T17:58:51.953Z","comments":true,"path":"2019/10/08/我的第一篇博客/","link":"","permalink":"https://kirbey.github.io/hexoBlog/2019/10/08/我的第一篇博客/","excerpt":"","text":"","categories":[],"tags":[{"name":"这篇博客用来测试HEXO是否搭建并上传成功","slug":"这篇博客用来测试HEXO是否搭建并上传成功","permalink":"https://kirbey.github.io/hexoBlog/tags/这篇博客用来测试HEXO是否搭建并上传成功/"}]}]}