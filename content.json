{"meta":{"title":"Kirbey's blog","subtitle":"自我学习的博客页面","description":null,"author":"kirbey","url":"https://kirbey.github.io/hexoBlog","root":"/hexoBlog/"},"pages":[{"title":"测试","date":"2019-10-07T17:31:33.000Z","updated":"2019-10-07T17:31:33.194Z","comments":true,"path":"测试/index.html","permalink":"https://kirbey.github.io/hexoBlog/测试/index.html","excerpt":"","text":""}],"posts":[{"title":"JS如何实现继承","slug":"JS如何实现继承","date":"2019-10-21T10:19:03.000Z","updated":"2019-10-21T10:36:43.637Z","comments":true,"path":"2019/10/21/JS如何实现继承/","link":"","permalink":"https://kirbey.github.io/hexoBlog/2019/10/21/JS如何实现继承/","excerpt":"","text":"js继承有五种实现方式：1、对象冒充123456function Parent(username)&#123; this.username = username; this.hello = function()&#123; alert(this.username); &#125; &#125; 123456789101112131415161718function Child(username,password)&#123; //通过以下3行实现将Parent的属性和方法追加到Child中，从而实现继承 //第一步：this.method是作为一个临时的属性，并且指向Parent所指向的对象， //第二步：执行this.method方法，即执行Parent所指向的对象函数 //第三步：销毁this.method属性，即此时Child就已经拥有了Parent的所有属性和方法 this.method = Parent; this.method(username);//最关键的一行 delete this.method; this.password = password; this.world = function()&#123; alert(this.password); &#125;&#125;var parent = new Parent(&quot;zhangsan&quot;);var child = new Child(&quot;lisi&quot;,&quot;123456&quot;);parent.hello();child.hello();child.world(); 2、call()方法 call方法是function类中的方法 call方法的第一个参数的值赋值给类（即方法）中出现的this call方法的第二个参数开始依次赋值给类（即方法）所接受的参数 12345678910111213141516171819202122232425function test(str)&#123; alert(this.name + &quot; &quot; + str);&#125;var object = new Object();object.name = &quot;zhangsan&quot;;test.call(object,&quot;langsin&quot;);//此时，第一个参数值object传递给了test类(即方法)中出现的this，而第二个参数&quot;langsin&quot;则赋值给了test类(即方法)的strfunction Parent(username)&#123; this.username = username; this.hello = function()&#123; alert(this.username); &#125;&#125;function Child(username,password)&#123; Parent.call(this,username); this.password = password; this.world = function()&#123; alert(this.password); &#125;&#125;var parent = new Parent(&quot;zhangsan&quot;);var child = new Child(&quot;lisi&quot;,&quot;123456&quot;);parent.hello();child.hello(); 3、apply() apply方法接受两个参数 A、第一个参数与call方法的第一个参数一样，即赋值给类(即方法)中出现的this B、第二个参数为数组类型，这个数组中的每个元素依次赋值给类(即方法)所接受的参数 123456789101112131415161718 function Parent(username)&#123; this.username = username; this.hello = function()&#123; alert(this.username); &#125;&#125;function Child(username,password)&#123; Parent.apply(this,new Array(username)); this.password = password; this.world = function()&#123; alert(this.password); &#125;&#125;var parent = new Parent(&quot;zhangsan&quot;);var child = new Child(&quot;lisi&quot;,&quot;123456&quot;);parent.hello();child.hello();child.world(); 4、原型链方式 即子类通过prototype将所有在父类中通过prototype追加的属性和方法都追加到Child，从而实现了继承 123456789101112131415161718 function Person()&#123;&#125;Person.prototype.hello = &quot;hello&quot;;Person.prototype.sayHello = function()&#123; alert(this.hello);&#125;function Child()&#123;&#125;Child.prototype = new Person();//这行的作用是：将Parent中将所有通过prototype追加的属性和方法都追加到Child，从而实现了继承Child.prototype.world = &quot;world&quot;;Child.prototype.sayWorld = function()&#123; alert(this.world);&#125;var c = new Child();c.sayHello();c.sayWorld(); 5、混合方式 混合了call方式原型链方式 123456789101112131415161718192021 function Parent(hello)&#123; this.hello = hello;&#125;Parent.prototype.sayHello = function()&#123; alert(this.hello);&#125;function Child(hello,world)&#123; Parent.call(this,hello);//将父类的属性继承过来 this.world = world;//新增一些属性&#125;Child.prototype = new Parent();//将父类的方法继承过来Child.prototype.sayWorld = function()&#123;//新增一些方法 alert(this.world);&#125;var c = new Child(&quot;zhangsan&quot;,&quot;lisi&quot;);c.sayHello();c.sayWorld(); 用class实现继承ES6提供了更接近传统语言的写法，引入了Class（类）这个概念。新的class写法让对象原型的写法更加清晰、更像面向对象编程的语法，也更加通俗易懂。 1234567891011121314151617181920212223242526272829303132333435363738class Animal &#123; // 构造方法，实例化的时候将会被调用，如果不指定，那么会有一个不带参数的默认构造函数. constructor(name,color) &#123; this.name = name; this.color = color; &#125; // toString 是原型对象上的属性 toString() &#123; console.log(&apos;name:&apos; + this.name + &apos;,color:&apos; + this.color); &#125; &#125; var animal = new Animal(&apos;dog&apos;,&apos;white&apos;);animal.toString();console.log(animal.hasOwnProperty(&apos;name&apos;)); //trueconsole.log(animal.hasOwnProperty(&apos;toString&apos;)); // falseconsole.log(animal.__proto__.hasOwnProperty(&apos;toString&apos;)); // trueclass Cat extends Animal &#123; constructor(action) &#123; // 子类必须要在constructor中指定super 方法，否则在新建实例的时候会报错. // 如果没有置顶consructor,默认带super方法的constructor将会被添加、 super(&apos;cat&apos;,&apos;white&apos;); this.action = action; &#125; toString() &#123; console.log(super.toString()); &#125;&#125;var cat = new Cat(&apos;catch&apos;)cat.toString();// 实例cat 是 Cat 和 Animal 的实例，和Es5完全一致。console.log(cat instanceof Cat); // trueconsole.log(cat instanceof Animal); // true","categories":[{"name":"前端","slug":"前端","permalink":"https://kirbey.github.io/hexoBlog/categories/前端/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://kirbey.github.io/hexoBlog/tags/javaScript/"}]},{"title":"用 async/await 来处理异步","slug":"用-async-await-来处理异步","date":"2019-10-20T08:00:14.000Z","updated":"2019-10-21T10:36:45.931Z","comments":true,"path":"2019/10/20/用-async-await-来处理异步/","link":"","permalink":"https://kirbey.github.io/hexoBlog/2019/10/20/用-async-await-来处理异步/","excerpt":"async先说一下async的用法，它作为一个关键字放到函数前面， 123async function timeout() &#123; return &apos;hello world&apos;;&#125; 什么作用呢？它的调用会返回一个promise 对象。如果返回的promise 对象又通过then或catch方法注册了回调函数，那么它执行完毕后，注册的回调函数就会放到异步执行队列中，进而得到执行。如果返回的promise 对象没有注册回调函数，它的执行和普通的函数的执行看不出什么区别。给timeout返回的promise注册一个回调函数，然后调用一下看看。async 函数的调用和普通函数数没有区别，直接加括号调用就可以了， 1234567async function timeout() &#123; return &apos;hello world&apos;&#125;console.log(timeout());timeout().then(result =&gt; &#123; console.log(result);&#125;)","text":"async先说一下async的用法，它作为一个关键字放到函数前面， 123async function timeout() &#123; return &apos;hello world&apos;;&#125; 什么作用呢？它的调用会返回一个promise 对象。如果返回的promise 对象又通过then或catch方法注册了回调函数，那么它执行完毕后，注册的回调函数就会放到异步执行队列中，进而得到执行。如果返回的promise 对象没有注册回调函数，它的执行和普通的函数的执行看不出什么区别。给timeout返回的promise注册一个回调函数，然后调用一下看看。async 函数的调用和普通函数数没有区别，直接加括号调用就可以了， 1234567async function timeout() &#123; return &apos;hello world&apos;&#125;console.log(timeout());timeout().then(result =&gt; &#123; console.log(result);&#125;) 看一下控制台(同时打印了timeout()的执行结果) async函数(timeout)的调用，确实返回promise 对象，并且Promise 还有status和value，如果async 函数中有返回一个值 ,当调用该函数时，内部会调用Promise.solve() 方法把它转化成一个promise 对象作为返回, 通过then()就可以获取到了。但如果timeout 函数内部抛出错误呢？ 那么就会调用Promise.reject() 返回一个promise 对象，调用promise.catch 进行捕获就要可以了。 如果async 函数执行完，返回的promise 也没有注册回调函数，比如函数内部做了一次for 循环，你会发现函数的调用，就是执行了函数体，和普通函数没有区别，唯一的区别就是函数执行完会返回一个promise 对象。 1234567async function timeout() &#123; for (let index = 0; index &lt; 3; index++) &#123; console.log(&apos;async &apos;+ index); &#125;&#125;console.log(timeout());console.log(&apos;outer&apos;)","categories":[{"name":"前端","slug":"前端","permalink":"https://kirbey.github.io/hexoBlog/categories/前端/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://kirbey.github.io/hexoBlog/tags/javaScript/"}]},{"title":"JSONP CORS和跨域","slug":"JSONP-CORS和跨域","date":"2019-10-20T07:39:20.000Z","updated":"2019-10-20T07:49:18.718Z","comments":true,"path":"2019/10/20/JSONP-CORS和跨域/","link":"","permalink":"https://kirbey.github.io/hexoBlog/2019/10/20/JSONP-CORS和跨域/","excerpt":"首先明确：JSONP与CORS的使用目的相同，并且都需要服务端和客户端同时支持，虽然功能上讲CORS更为强大，但是需要根据应用场景选择使用哪一个。 JSONP（json with padding 填充式json）利用了使用src引用静态资源时不受跨域限制的机制。主要在客户端搞一个回调做一些数据接收与操作的处理，并把这个回调函数名告知服务端，而服务端需要做的是按照javascript的语法把数据放到约定好的回调函数之中即可。jQuery很早之前就已经吧JSONP语法糖化了，使用起来会更加方便。 CORS（Cross-origin resource sharing 跨域资源共享）依附于AJAX，通过添加HTTP Hearder部分字段请求与获取有权限访问的资源。CORS对开发者是透明的，因为浏览器会自动根据请求的情况（简单和复杂）做出不同的处理。CORS的关键是服务端的配置支持。由于CORS是W3C中一项较“新”的方案，以至于各大网页解析引擎还没有对其进行严格规格的实现，所以不同引擎下可能会有一些不一致。 两者优点与缺点大致互补，放在一块介绍： JSONP的主要优势在于对浏览器的支持较好；虽然目前主流浏览器支持CORS，但IE10以下不支持CORS。 JSONP只能用于获取资源（即只读，类似于GET请求）；CORS支持所有类型的HTTP请求，功能完善。（这点JSONP被玩虐，但大部分情况下GET已经能满足需求了） JSONP的错误处理机制并不完善，我们没办法进行错误处理；而CORS可以通过onerror事件监听错误，并且浏览器控制台会看到报错信息，利于排查。 JSONP只会发一次请求；而对于复杂请求，CORS会发两次请求。 始终觉得安全性这个东西是相对的，没有绝对的安全，也做不到绝对的安全。毕竟JSONP并不是跨域规范，它存在很明显的安全问题：callback参数注入和资源访问授权设置。CORS好歹也算是个跨域规范，在资源访问授权方面进行了限制（Access-Control-Allow-Origin），而且标准浏览器都做了安全限制，比如拒绝手动设置origin字段，相对来说是安全了一点。 但是回过头来看一下，就算是不安全的JSONP，我们依然可以在服务端端进行一些权限的限制，服务端和客户端也都依然可以做一些注入的安全处理，哪怕被攻克，它也只能读一些东西。就算是比较安全的CORS，同样可以在服务端设置出现漏洞或者不在浏览器的跨域限制环境下进行攻击，而且它不仅可以读，还可以写。","text":"首先明确：JSONP与CORS的使用目的相同，并且都需要服务端和客户端同时支持，虽然功能上讲CORS更为强大，但是需要根据应用场景选择使用哪一个。 JSONP（json with padding 填充式json）利用了使用src引用静态资源时不受跨域限制的机制。主要在客户端搞一个回调做一些数据接收与操作的处理，并把这个回调函数名告知服务端，而服务端需要做的是按照javascript的语法把数据放到约定好的回调函数之中即可。jQuery很早之前就已经吧JSONP语法糖化了，使用起来会更加方便。 CORS（Cross-origin resource sharing 跨域资源共享）依附于AJAX，通过添加HTTP Hearder部分字段请求与获取有权限访问的资源。CORS对开发者是透明的，因为浏览器会自动根据请求的情况（简单和复杂）做出不同的处理。CORS的关键是服务端的配置支持。由于CORS是W3C中一项较“新”的方案，以至于各大网页解析引擎还没有对其进行严格规格的实现，所以不同引擎下可能会有一些不一致。 两者优点与缺点大致互补，放在一块介绍： JSONP的主要优势在于对浏览器的支持较好；虽然目前主流浏览器支持CORS，但IE10以下不支持CORS。 JSONP只能用于获取资源（即只读，类似于GET请求）；CORS支持所有类型的HTTP请求，功能完善。（这点JSONP被玩虐，但大部分情况下GET已经能满足需求了） JSONP的错误处理机制并不完善，我们没办法进行错误处理；而CORS可以通过onerror事件监听错误，并且浏览器控制台会看到报错信息，利于排查。 JSONP只会发一次请求；而对于复杂请求，CORS会发两次请求。 始终觉得安全性这个东西是相对的，没有绝对的安全，也做不到绝对的安全。毕竟JSONP并不是跨域规范，它存在很明显的安全问题：callback参数注入和资源访问授权设置。CORS好歹也算是个跨域规范，在资源访问授权方面进行了限制（Access-Control-Allow-Origin），而且标准浏览器都做了安全限制，比如拒绝手动设置origin字段，相对来说是安全了一点。 但是回过头来看一下，就算是不安全的JSONP，我们依然可以在服务端端进行一些权限的限制，服务端和客户端也都依然可以做一些注入的安全处理，哪怕被攻克，它也只能读一些东西。就算是比较安全的CORS，同样可以在服务端设置出现漏洞或者不在浏览器的跨域限制环境下进行攻击，而且它不仅可以读，还可以写。 应用场景： 如果你需要兼容IE低版本浏览器，无疑，JSONP。 如果你需要对服务端资源进行谢操作，无疑，CORS。 其他情况的话，根据自己的对需求的分析和对两者的理解来吧。 什么是跨域： 跨域：指的是浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器对javascript施加的安全限制。 例如：a页面想获取b页面资源，如果a、b页面的协议、域名、端口、子域名不同，所进行的访问行动都是跨域的，而浏览器为了安全问题一般都限制了跨域访问，也就是不允许跨域请求资源。注意：跨域限制访问，其实是浏览器的限制。理解这一点很重要！！！ 同源策略：是指协议，域名，端口都要相同，其中有一个不同都会产生跨域；跨域访问示例假设有两个网站，A网站部署在：http://localhost:81 即本地ip端口81上；B网站部署在：http://localhost:82 即本地ip端口82上。现在A网站的页面想去访问B网站的信息，A网站页面的代码如下（这里使用jquery的异步请求）1234567$(function ()&#123; $.get(&quot;http://localhost:82/api/values&quot;, &#123;&#125;,function (result) &#123; $(&quot;#show&quot;).html(result); &#125;)&#125;)； 从错误信息可以看出以上出现了跨域问题！","categories":[{"name":"前端","slug":"前端","permalink":"https://kirbey.github.io/hexoBlog/categories/前端/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://kirbey.github.io/hexoBlog/tags/javaScript/"}]},{"title":"promise","slug":"promise","date":"2019-10-19T08:33:33.000Z","updated":"2019-10-20T02:51:46.393Z","comments":true,"path":"2019/10/19/promise/","link":"","permalink":"https://kirbey.github.io/hexoBlog/2019/10/19/promise/","excerpt":"promise是什么1、主要用于异步计算。2、可以将异步操作队列化，按照期望的顺序执行，返回符合预期的结果。3、可以再对象之间传递和操作promise，帮助我们处理队列 为什么会有promise为了避免界面冻结同步：假设你去了一家饭店，找个位置，叫来服务员，这个时候服务员对你说，对不起我是“同步”服务员，我要服务完这张桌子才能招呼你。那桌客人明明已经吃上了，你只是想要个菜单，这么小的动作，服务员却要你等到别人的一个大动作完成之后，才能再来招呼你，这个便是同步的问题：也就是“顺序交付的工作1234，必须按照1234的顺序完成”。 异步：则是将耗时很长的A交付的工作交给系统之后，就去继续做B交付的工作，。等到系统完成了前面的工作之后，再通过回调或者事件，继续做A剩下的工作。AB工作的完成顺序，和交付他们的时间顺序无关，所以叫“异步”。 异步操作的常见语法1.事件监听 123456document.getElementById(&apos;#start&apos;).addEventListener(&apos;click&apos;, start, false);function start() &#123; // 响应事件，进行相应的操作&#125;// jquery on 监听$(&apos;#start&apos;).on(&apos;click&apos;, start)","text":"promise是什么1、主要用于异步计算。2、可以将异步操作队列化，按照期望的顺序执行，返回符合预期的结果。3、可以再对象之间传递和操作promise，帮助我们处理队列 为什么会有promise为了避免界面冻结同步：假设你去了一家饭店，找个位置，叫来服务员，这个时候服务员对你说，对不起我是“同步”服务员，我要服务完这张桌子才能招呼你。那桌客人明明已经吃上了，你只是想要个菜单，这么小的动作，服务员却要你等到别人的一个大动作完成之后，才能再来招呼你，这个便是同步的问题：也就是“顺序交付的工作1234，必须按照1234的顺序完成”。 异步：则是将耗时很长的A交付的工作交给系统之后，就去继续做B交付的工作，。等到系统完成了前面的工作之后，再通过回调或者事件，继续做A剩下的工作。AB工作的完成顺序，和交付他们的时间顺序无关，所以叫“异步”。 异步操作的常见语法1.事件监听 123456document.getElementById(&apos;#start&apos;).addEventListener(&apos;click&apos;, start, false);function start() &#123; // 响应事件，进行相应的操作&#125;// jquery on 监听$(&apos;#start&apos;).on(&apos;click&apos;, start) 2.回调 1234567891011// 比较常见的有ajax$.ajax(&apos;http://www.wyunfei.com/&apos;, &#123; success (res) &#123; // 这里可以监听res返回的数据做回调逻辑的处理 &#125;&#125;)// 或者在页面加载完毕后回调$(function() &#123; // 页面结构加载完成，做回调逻辑处理&#125;) 有了nodejs以后对异步的依赖进一步加剧了大家都知道在nodeJS出来之前PHP、Java、python等后台语言已经很成熟了，nodejs要想能够有自己的一片天，那就得拿出点自己的绝活：无阻塞高并发，是nodeJS的招牌，要达到无阻塞高并发异步是其基本保障举例： 查询数据从数据库，PHP第一个任务查询数据，后面有了新任务，那么后面任务会被挂起排队；而nodeJS是第一个任务挂起交给数据库去跑，然后去接待第二个任务交给对应的系统组件去处理挂起，接着去接待第三个任务…那这个样子的处理必然要依赖于异步操作。 异步回调的问题之前处理异步是通过纯粹的回调函数的形式进行处理很容易进入到回调地狱中，剥夺了函数return的能力问题可以解决，但是难以读懂，维护困难稍有不慎就会踏入回调地狱 - 嵌套层次深，不好维护 一般情况我们一次性调用API就可以完成请求。有些情况需要多次调用服务器API，就会形成一个链式调用，比如为了完成一个功能，我们需要调用API1、API2、API3，依次按照顺序进行调用，这个时候就会出现回调地狱的问题 promisepromise是一个对象，对象和函数的区别就是对象可以保存状态，函数不可以（闭包除外）。并未剥夺函数的return能力，因此无需层层传递callback，进行回调获取数据。代码风格容易理解，便于维护。多个异步等待合并便于解决。 promise详解12345678910new Promise( function (resolve, reject) &#123; // 一段耗时的异步操作 resolve(&apos;成功&apos;) // 数据处理完成 // reject(&apos;失败&apos;) // 数据处理出错 &#125;).then( (res) =&gt; &#123;console.log(res)&#125;, // 成功 (err) =&gt; &#123;console.log(err)&#125; // 失败) resolve作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。 promise有三个状态：1、pending[待定]初始状态2、fulfilled[实现]操作成功3、rejected[被否决]操作失败当promise状态发生改变，就会触发then()里的响应函数处理后续步骤；promise状态一经改变，不会再变。 Promise对象的状态改变，只有两种可能：从pending变为fulfilled从pending变为rejected。这两种情况只要发生，状态就凝固了，不会再变了。简单示例1234567new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&apos;hello&apos;) &#125;, 2000)&#125;).then(res =&gt; &#123; console.log(res)&#125;) 分两次，顺序执行1234567891011121314new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&apos;hello&apos;) &#125;, 2000) &#125;).then(val =&gt; &#123; console.log(val) // 参数val = &apos;hello&apos; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&apos;world&apos;) &#125;, 2000) &#125;) &#125;).then(val =&gt; &#123; console.log(val) // 参数val = &apos;world&apos; &#125;) promise完成后then() 12345678910 let pro = new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&apos;hello world&apos;) &#125;, 2000)&#125;)setTimeout(() =&gt; &#123; pro.then(value =&gt; &#123; console.log(value) // hello world&#125;)&#125;, 2000) 结论：promise作为队列最为重要的特性，我们在任何一个地方生成了一个promise队列之后，我们可以把他作为一个变量传递到其他地方。 假如在.then()的函数里面不返回新的promise，会怎样？ * then() * 1、接收两个函数作为参数，分别代表fulfilled（成功）和rejected（失败）2、.then()返回一个新的Promise实例，所以它可以链式调用3、当前面的Promise状态改变时，.then()根据其最终状态，选择特定的状态响应函数执行4、状态响应函数可以返回新的promise，或其他值，不返回值也可以我们可以认为它返回了一个null；5、如果返回新的promise，那么下一级.then()会在新的promise状态改变之后执行6、如果返回其他任何值，则会立即执行下一级.then().then()里面有.then()的情况 对于我们来说，此时最好将其展开，也是一样的结果，而且会更好读： 错误处理1、第一种错误处理 2、第二种错误处理 处理错误的两种做法错误处理两种做法：第一种：reject(‘错误信息’).then(() =&gt; {}, () =&gt; {错误处理逻辑})第二种：throw new Error(‘错误信息’).catch( () =&gt; {错误处理逻辑})推荐使用第二种方式，更加清晰好读，并且可以捕获前面所有的错误（可以捕获N个then回调错误） catch() + then() 第一种情况 结论：catch也会返回一个promise实例，并且是resolved状态 第二种情况 结论：抛出错误变为rejected状态，所以绕过两个then直接跑到最下面的catch Promise.all() 批量执行*Promise.all([p1, p2, p3])用于将多个promise实例，包装成一个新的Promise实例，返回的实例就是普通的promise它接收一个数组作为参数数组里可以是Promise对象，也可以是别的值，只有Promise会等待状态改变当所有的子Promise都完成，该Promise完成，返回值是全部值得数组有任何一个失败，该Promise失败，返回值是第一个失败的子Promise结果1234567891011121314151617181920212223242526272829//切菜 function cutUp()&#123; console.log(&apos;开始切菜。&apos;); var p = new Promise(function(resolve, reject)&#123; //做一些异步操作 setTimeout(function()&#123; console.log(&apos;切菜完毕！&apos;); resolve(&apos;切好的菜&apos;); &#125;, 1000); &#125;); return p; &#125; //烧水 function boil()&#123; console.log(&apos;开始烧水。&apos;); var p = new Promise(function(resolve, reject)&#123; //做一些异步操作 setTimeout(function()&#123; console.log(&apos;烧水完毕！&apos;); resolve(&apos;烧好的水&apos;); &#125;, 1000); &#125;); return p; &#125; Promise.all([cutUp(), boil()]) .then((result) =&gt; &#123; console.log(&apos;准备工作完毕&apos;); console.log(result); &#125;) Promise.race() 类似于Promise.all() ，区别在于它有任意一个完成就算完成 1234567891011121314let p1 = new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&apos;I\\`m p1 &apos;) &#125;, 1000) &#125;); let p2 = new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&apos;I\\`m p2 &apos;) &#125;, 2000) &#125;); Promise.race([p1, p2]) .then(value =&gt; &#123; console.log(value) &#125;) 常见用法异步操作和定时器放在一起，，如果定时器先触发，就认为超时，告知用户；例如我们要从远程的服务家在资源如果5000ms还没有加载过来我们就告知用户加载失败 现实中的用法回调包装成Promise，他有两个显而易见的好处：1、可读性好2、返回 的结果可以加入任何Promise队列 实战示例，回调地狱和promise对比：12345678910111213141516171819202122232425262728293031323334353637383940414243/*** 第一步：找到北京的id 第二步：根据北京的id -&gt; 找到北京公司的id 第三步：根据北京公司的id -&gt; 找到北京公司的详情 目的：模拟链式调用、回调地狱 ***/ // 回调地狱 // 请求第一个API: 地址在北京的公司的id $.ajax(&#123; url: &apos;https://www.easy-mock.com/mock/5a52256ad408383e0e3868d7/lagou/city&apos;, success (resCity) &#123; let findCityId = resCity.filter(item =&gt; &#123; if (item.id == &apos;c1&apos;) &#123; return item &#125; &#125;)[0].id $.ajax(&#123; // 请求第二个API: 根据上一个返回的在北京公司的id “findCityId”，找到北京公司的第一家公司的id url: &apos;https://www.easy-mock.com/mock/5a52256ad408383e0e3868d7/lagou/position-list&apos;, success (resPosition) &#123; let findPostionId = resPosition.filter(item =&gt; &#123; if(item.cityId == findCityId) &#123; return item &#125; &#125;)[0].id // 请求第三个API: 根据上一个API的id(findPostionId)找到具体公司，然后返回公司详情 $.ajax(&#123; url: &apos;https://www.easy-mock.com/mock/5a52256ad408383e0e3868d7/lagou/company&apos;, success (resCom) &#123; let comInfo = resCom.filter(item =&gt; &#123; if (findPostionId == item.id) &#123; return item &#125; &#125;)[0] console.log(comInfo) &#125; &#125;) &#125; &#125;) &#125; &#125;) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263 // Promise 写法 // 第一步：获取城市列表 const cityList = new Promise((resolve, reject) =&gt; &#123; $.ajax(&#123; url: &apos;https://www.easy-mock.com/mock/5a52256ad408383e0e3868d7/lagou/city&apos;, success (res) &#123; resolve(res) &#125; &#125;) &#125;) // 第二步：找到城市是北京的id cityList.then(res =&gt; &#123; let findCityId = res.filter(item =&gt; &#123; if (item.id == &apos;c1&apos;) &#123; return item &#125; &#125;)[0].id findCompanyId().then(res =&gt; &#123; // 第三步（2）：根据北京的id -&gt; 找到北京公司的id let findPostionId = res.filter(item =&gt; &#123; if(item.cityId == findCityId) &#123; return item &#125; &#125;)[0].id // 第四步（2）：传入公司的id companyInfo(findPostionId) &#125;) &#125;) // 第三步（1）：根据北京的id -&gt; 找到北京公司的id function findCompanyId () &#123; let aaa = new Promise((resolve, reject) =&gt; &#123; $.ajax(&#123; url: &apos;https://www.easy-mock.com/mock/5a52256ad408383e0e3868d7/lagou/position-list&apos;, success (res) &#123; resolve(res) &#125; &#125;) &#125;) return aaa &#125;// 第四步：根据上一个API的id(findPostionId)找到具体公司，然后返回公司详情function companyInfo (id) &#123; let companyList = new Promise((resolve, reject) =&gt; &#123; $.ajax(&#123; url: &apos;https://www.easy-mock.com/mock/5a52256ad408383e0e3868d7/lagou/company&apos;, success (res) &#123; let comInfo = res.filter(item =&gt; &#123; if (id == item.id) &#123; return item &#125; &#125;)[0] console.log(comInfo) &#125; &#125;) &#125;)&#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://kirbey.github.io/hexoBlog/categories/前端/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://kirbey.github.io/hexoBlog/tags/javaScript/"}]},{"title":"ES6常用语法","slug":"ES6常用语法","date":"2019-10-18T07:38:41.000Z","updated":"2019-10-18T08:59:53.300Z","comments":true,"path":"2019/10/18/ES6常用语法/","link":"","permalink":"https://kirbey.github.io/hexoBlog/2019/10/18/ES6常用语法/","excerpt":"字符串扩展常用的一些方法 at() 1234// 参数传入角标，返回值为角标对应的字符&apos;abc&apos;.at(0) // &apos;a&apos;&apos;吉&apos;.at(0) // &apos;吉&apos;// 与ES5中charAt()不同之处，汉字的话ES5会返回对应Unicode编码，js内部用UTF-16 includes(),startsWith(),endsWith()includes(),返回值为布尔值，表示能否找到参数的字符串startsWith(),返回值为布尔值，表示参数字符串是否在原字符串的头部endsWith(),返回布尔值，表示参数字符串是否在原字符串的尾部这三个方法都支持第二个参数，表示开始搜索的位置。endsWith的行为与其他两个方法有所不同。它针对前N个字符，而其他两个方法针对从第n个位置直到字符串结束。 1234567let str = &apos;Hello World&apos;str.includes(&apos;Hello&apos;) // truestr.startsWith(&apos;Hello&apos;) // truestr.endsWith(&apos;d&apos;) // truestr.startsWith(&apos;world&apos;, 6) // truestr.endsWith(&apos;Hello&apos;, 5) // truestr.includes(&apos;Hello&apos;, 6) // false","text":"字符串扩展常用的一些方法 at() 1234// 参数传入角标，返回值为角标对应的字符&apos;abc&apos;.at(0) // &apos;a&apos;&apos;吉&apos;.at(0) // &apos;吉&apos;// 与ES5中charAt()不同之处，汉字的话ES5会返回对应Unicode编码，js内部用UTF-16 includes(),startsWith(),endsWith()includes(),返回值为布尔值，表示能否找到参数的字符串startsWith(),返回值为布尔值，表示参数字符串是否在原字符串的头部endsWith(),返回布尔值，表示参数字符串是否在原字符串的尾部这三个方法都支持第二个参数，表示开始搜索的位置。endsWith的行为与其他两个方法有所不同。它针对前N个字符，而其他两个方法针对从第n个位置直到字符串结束。 1234567let str = &apos;Hello World&apos;str.includes(&apos;Hello&apos;) // truestr.startsWith(&apos;Hello&apos;) // truestr.endsWith(&apos;d&apos;) // truestr.startsWith(&apos;world&apos;, 6) // truestr.endsWith(&apos;Hello&apos;, 5) // truestr.includes(&apos;Hello&apos;, 6) // false repeat()1&apos;x&apos;.repeat(3) // &quot;xxx&quot; 注意：参数不能传负数和infinity，参数NaN为0，参数为字符串会先转换为数字4. padStart(),padEnd()参数两个，第一个为位数，第二个是用什么补全，省略第二个参数时默认为空格补全。这两个更多的用途是补全指定位数 123&apos;1&apos;.padStart(10, &apos;0&apos;) // &quot;0000000001&quot;&apos;12&apos;.padStart(10, &apos;0&apos;) // &quot;0000000012&quot;&apos;123456&apos;.padStart(10, &apos;0&apos;) // &quot;0000123456&quot; 数组拓展1.Array.from()Array.from方法用于将两类对象转为真正的数组：类似数组的对象(array-like object)和可遍历(iterable)的对象(包括ES6新增的数据结构Set和Map)2. …运算符拓展运算符(spread)是三个点(…)。它好比rest参数的逆运算，将一个数组转为用逗号分隔的参数序列。 12345console.log(...[1, 2, 3])// 1 2 3console.log(1, ...[2, 3, 4], 5)// 1 2 3 4 5 关于函数传参的问题，如果函数直接用…传参，传入的参数实际上是一个数组，且后面不能再有参数。如果函数参数定义了一个数组，用…传入，实际上参数为数值中的值。 12345678function fn(...items)&#123;&#125;//等同于function fn([数组内容])&#123;&#125;let items = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]function fn(...items)&#123;&#125;// 等同于function fn(&apos;a&apos;, &apos;b&apos;, &apos;c&apos;) &#123;&#125; …运算符的运用复制数组（克隆数组）12let arr1 = [1, 2, 3]let arr2 = [...arr1] // [1, 2, 3] 合并数组 1234const arr1 = [&apos;a&apos;, &apos;b&apos;]const arr2 = [&apos;c&apos;]const arr3 = [&apos;d&apos;, &apos;e&apos;]const arr4 = [...arr1, ...arr2, ...arr3] // [ &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos; ] 与解构赋值结合 123const [first, ...rest] = [1, 2, 3, 4, 5];first // 1rest // [2, 3, 4, 5] 将字符串转换为真正的数组 12[...&apos;hello&apos;]// [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ] 数组实例的fill()三个参数，后面两个可以省略，第一个参数为替换成什么内容，第二个为替换的其实位置，第三个为替换的终止位置 12345[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].fill(7)// [7, 7, 7][&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].fill(7, 1, 2)// [&apos;a&apos;, 7, &apos;c&apos;] 数组实例的entries(),keys()和values()三个方法都是遍历数组，都可以用for…of…唯一的区别是keys()是对键名的遍历、values()是对键值得遍历，entries()是对键值对的遍历。1234567891011121314151617for (let index of [&apos;a&apos;, &apos;b&apos;].keys()) &#123; console.log(index);&#125;// 0// 1for (let elem of [&apos;a&apos;, &apos;b&apos;].values()) &#123; console.log(elem);&#125;// &apos;a&apos;// &apos;b&apos;for (let [index, elem] of [&apos;a&apos;, &apos;b&apos;].entries()) &#123; console.log(index, elem);&#125;// 0 &quot;a&quot;// 1 &quot;b&quot; 对象拓展对象的话，解构赋值就不说了太基础了，我用的最多的就是…运算符和Object.assgi(),实际上…底层的方法就是assign() Symbol js数据类型除了string.number,boolean,undefined,null,object,第七种为symbol，作用是防止定义变量时出现重复的定义导致覆盖的一些问题 Set和Map结构1.SetES6提供了新的数据结构Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。Set本身是一个构造函数，用来生成Set数据结构。此结构不会添加重复的值 1234567891011// 例一const set = new Set([1, 2, 3, 4, 4]);[...set]// [1, 2, 3, 4]// 例二const items = new Set([1, 2, 3, 4, 5, 5, 5, 5]);items.size // 5// 例三 数组去重[...new Set(array)] ———-(再其它文章中详细说明用法)———- proxy拦截1.基本说明Proxy可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy这个词的原意是代理，用在这里表示有它来“代理”某些操作，可以译为“代理器”。 12345678910var obj = new Proxy(&#123;&#125;, &#123; get: function (target, key, receiver) &#123; console.log(`getting $&#123;key&#125;!`); return Reflect.get(target, key, receiver); &#125;, set: function (target, key, value, receiver) &#123; console.log(`setting $&#123;key&#125;!`); return Reflect.set(target, key, value, receiver); &#125;&#125;); 2.get()方法get方法用于拦截某个属性的读取操作，可以接受三个参数，依次为目标对象、属性名和proxy实例本身（即this关键字指向的那个对象），其中最后一个参数可选。 12345678910111213141516var person = &#123; name: &quot;张三&quot;&#125;;var proxy = new Proxy(person, &#123; get: function(target, property) &#123; if (property in target) &#123; return target[property]; &#125; else &#123; throw new ReferenceError(&quot;Property \\&quot;&quot; + property + &quot;\\&quot; does not exist.&quot;); &#125; &#125;&#125;);proxy.name // &quot;张三&quot;proxy.age // 抛出一个错误 3.set()方法set方法用来拦截某个属性的赋值操作，可以接受四个参数，依次为目标对象、属性名、属性值和Proxy实例本身，其中最后一个参数可选。 1234567891011121314151617181920212223let validator = &#123; set: function(obj, prop, value) &#123; if (prop === &apos;age&apos;) &#123; if (!Number.isInteger(value)) &#123; throw new TypeError(&apos;The age is not an integer&apos;); &#125; if (value &gt; 200) &#123; throw new RangeError(&apos;The age seems invalid&apos;); &#125; &#125; // 对于满足条件的 age 属性以及其他属性，直接保存 obj[prop] = value; &#125;&#125;;let person = new Proxy(&#123;&#125;, validator);person.age = 100;person.age // 100person.age = &apos;young&apos; // 报错person.age = 300 // 报错 async和await1.基本说明async函数返回一个Promise对象，可以使用then方法添加回调函数。当函数执行的时候，一旦通过await就会先返回，等到异步操作完成，再接着执行函数体后面的语句。2.await命令正常情况下,await命令后面是一个Promise对象。如果不是，会被转成一个立即resolve的Promise对象。 123456async function f() &#123; return await 123;&#125;f().then(v =&gt; console.log(v))// 123 class类说明几个问题1.constructor()constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显示定义，一个空的constructor方法会被默认添加。 1234567class Point &#123;&#125;// 等同于class Point &#123; constructor() &#123;&#125;&#125; 2.类继承中的super()如果你要用类继承的话，里面一定要写super(),它是指定父类的this的，否则会报错 1234567class A &#123;&#125;class B extends A &#123; constructor() &#123; super(); &#125;&#125; 浏览器加载1.defer和async 12&lt;script src=&quot;path/to/myModule.js&quot; defer&gt;&lt;/script&gt;&lt;script src=&quot;path/to/myModule.js&quot; async&gt;&lt;/script&gt; defer与async的区别是：defer要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），才会执行；async一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。一句话，defer是“渲染完再执行”，async是“下载完就执行”。另外，如果有多个defer脚本，会按照它们在页面出现的顺序加载，而多个async脚本是不能保证加载顺序的。2.ES6新语法浏览器加载ES6模块，也是用标签，但是要加入type = \"module\"属性。浏览器对于带有type = \"module\"的，都是异步加载，不会造成堵塞浏览器，即等到整个页面渲染完，再执行模块脚本，等同于打开了标签的defer属性。 1&lt;script type=&quot;module&quot; src=&quot;./foo.js&quot;&gt;&lt;/script&gt; ES6模块也允许内嵌在网页中，语法行为与加载外部脚本完全一致。 1234&lt;script type=&quot;module&quot;&gt; import utils from &quot;./utils.js&quot;; // other code&lt;/script&gt; 对于外部的模块脚本（上例是foo.js），有几点需要注意。 12345- 代码是在模块作用域之中运行，而不是在全局作用域运行。模块内部的顶层变量，外部不可见。- 模块脚本自动采用严格模式，不管有没有声明use strict。- 模块之中，可以使用import命令加载其他模块（.js后缀不可省略，需要提供绝对 URL 或相对 URL），也可以使用export命令输出对外接口。- 模块之中，顶层的this关键字返回undefined，而不是指向window。也就是说，在模块顶层使用this关键字，是无意义的。- 同一个模块如果加载多次，将只执行一次。","categories":[{"name":"前端","slug":"前端","permalink":"https://kirbey.github.io/hexoBlog/categories/前端/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://kirbey.github.io/hexoBlog/tags/javaScript/"}]},{"title":"入门vuex（vue状态管理）","slug":"入门vuex（vue状态管理）","date":"2019-10-16T01:47:00.000Z","updated":"2019-10-18T08:03:42.349Z","comments":true,"path":"2019/10/16/入门vuex（vue状态管理）/","link":"","permalink":"https://kirbey.github.io/hexoBlog/2019/10/16/入门vuex（vue状态管理）/","excerpt":"#Vuex 是什么？Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 Vue 的官方调试工具 devtools extension，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。 #什么是“状态管理模式”？让我们从一个简单的 Vue 计数应用开始： 123456789101112131415161718new Vue(&#123; // state data () &#123; return &#123; count: 0 &#125; &#125;, // view template: ` &lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt; `, // actions methods: &#123; increment () &#123; this.count++ &#125; &#125;&#125;)","text":"#Vuex 是什么？Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 Vue 的官方调试工具 devtools extension，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。 #什么是“状态管理模式”？让我们从一个简单的 Vue 计数应用开始： 123456789101112131415161718new Vue(&#123; // state data () &#123; return &#123; count: 0 &#125; &#125;, // view template: ` &lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt; `, // actions methods: &#123; increment () &#123; this.count++ &#125; &#125;&#125;) 这个状态自管理应用包含以下几个部分： *state，驱动应用的数据源；*view，以声明方式将 state 映射到视图；*actions，响应在 view 上的用户输入导致的状态变化。以下是一个表示“单向数据流”理念的简单示意： 但是，当我们的应用遇到多个组件共享状态时，单向数据流的简洁性很容易被破坏：*多个视图依赖于同一状态。*来自不同视图的行为需要变更同一状态。对于问题一，传参的方法对于多层嵌套的组件将会非常繁琐，并且对于兄弟组件间的状态传递无能为力。对于问题二，我们经常会采用父子组件直接引用或者通过事件来变更和同步状态的多份拷贝。以上的这些模式非常脆弱，通常会导致无法维护的代码。 因此，我们为什么不把组件的共享状态抽取出来，以一个全局单例模式管理呢？在这种模式下，我们的组件树构成了一个巨大的“视图”，不管在树的哪个位置，任何组件都能获取状态或者触发行为！ 通过定义和隔离状态管理中的各种概念并通过强制规则维持视图和状态间的独立性，我们的代码将会变得更结构化且易维护。 这就是 Vuex 背后的基本思想，借鉴了 Flux、Redux 和 The Elm Architecture。与其他模式不同的是，Vuex 是专门为 Vue.js 设计的状态管理库，以利用 Vue.js 的细粒度数据响应机制来进行高效的状态更新。","categories":[{"name":"前端","slug":"前端","permalink":"https://kirbey.github.io/hexoBlog/categories/前端/"}],"tags":[{"name":"vuex","slug":"vuex","permalink":"https://kirbey.github.io/hexoBlog/tags/vuex/"}]},{"title":"AJAX","slug":"AJAX","date":"2019-10-10T15:42:59.000Z","updated":"2019-10-10T15:54:43.709Z","comments":true,"path":"2019/10/10/AJAX/","link":"","permalink":"https://kirbey.github.io/hexoBlog/2019/10/10/AJAX/","excerpt":"AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。 AJAX 不是新的编程语言，而是一种使用现有标准的新方法。 AJAX最大的优点是，在不重新加载整个页面的情况下，可以与服务器交换数据并更新部分网页内容。 AJAX不需要任何浏览器插件，但需要用户允许JavaScript在浏览器上执行。","text":"AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。 AJAX 不是新的编程语言，而是一种使用现有标准的新方法。 AJAX最大的优点是，在不重新加载整个页面的情况下，可以与服务器交换数据并更新部分网页内容。 AJAX不需要任何浏览器插件，但需要用户允许JavaScript在浏览器上执行。 AJAX应用： 运用XHTML+CSS来表达资讯； 运用javaScript操作DOM来执行动态效果； 运用XML和XSLT来操作资料； 运用XMLHttpRequest或新的Fetch API与网页服务器进行异步资料交换； 注意：AJAX与Flash、Silverlight和Java Applet等RIA技术是有区分的。 什么是AJAX： AJAX = 异步javaScript和XML。 AJAX是一种用于创建快速动态网页的技术。 通过在后台与服务器进行少量数据交换，AJAX可以使网页实现异步更新。只意味着可以在不重新加载这个网页的情况下，对网页的部分进行更新。 传统的网页要实现更新必须重新加载整个页面。 有很多使用AJAX的应用程序案例，渣浪，google地图，开心网等。 AJAX工作原理： AJAX使基于现有的internet标准 并且联合使用它们： XMLHttpRequest对象（异步的服务器交换数据）； javaScript/DOM（信息显示/交互）； CSS（给数据定义样式）； XML（作为转换数据的格式）； Google Suggest在 2005 年，Google 通过其 Google Suggest 使 AJAX 变得流行起来。 Google Suggest 使用 AJAX 创造出动态性极强的 web 界面：当您在谷歌的搜索框输入关键字时，JavaScript 会把这些字符发送到服务器，然后服务器会返回一个搜索建议的列表。 XMLHttpRequest对象 所有现代浏览器均支持XMLHttpRequest对象。 XMLHttpRequest用于在后台与服务器交换数据，这意味着再不用加载整个页面的情况下，对王爷的部分进行更新。 创建XMLHttpRequest对象 所有现代浏览器均内建XMLHttprequest对象 创建XMLHttpRequest对象的语法： 1var iable=new XMLHttpRequest(); 实例： 1234567891011var xmlhttp;if (window.XMLHttpRequest)&#123; // IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码 xmlhttp=new XMLHttpRequest();&#125;else&#123; // IE6, IE5 浏览器执行代码 xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);&#125; 向服务器发送请求： 如需将请求发送到服务器，我们使用XMLHttpRequest对象的open（）和send（）方法： 12xmlhttp.open(&quot;GET&quot;,&quot;ajax_info.txt&quot;,true);xmlhttp.send(); GET还是POST 与POST相比GET更快也更简单，并且在大部分情况下都能用。 然而，在以下情况中请使用POST请求： 无法使用缓存文件（更新服务器上的数据或文件库） 向服务器发送大量数据（POST没有数据量限制） 发送包含未知字符的用户输入时，POST也比GET更可靠。 GET请求 一个简单的GET请求： 12xmlhttp.open(&quot;GET&quot;,&quot;/try/ajax/demo_get.php&quot;,true);xmlhttp.send(); 在上面的例子中你可能得到的时缓存的结果。 为了避免这种情况请向URL添加一个唯一的ID: 12xmlhttp.open(&quot;GET&quot;,&quot;/try/ajax/demo_get.php?t=&quot; + Math.random(),true);xmlhttp.send(); 如果你希望通过GET请求向服务器发送信息请向URL添加信息： 12xmlhttp.open(&quot;GET&quot;,&quot;/try/ajax/demo_get2.php?fname=Henry&amp;lname=Ford&quot;,true);xmlhttp.send(); POET请求 一个简单的POST请求： 12xmlhttp.open(&quot;POST&quot;,&quot;/try/ajax/demo_post.php&quot;,true);xmlhttp.send(); 如果需要向HTML表单那样POST数据，请使用setRequestHeader（）来添加HTTP头，然后在send（）方法中规定您希望发送的数据： 123xmlhttp.open(&quot;POST&quot;,&quot;/try/ajax/demo_post2.php&quot;,true);xmlhttp.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);xmlhttp.send(&quot;fname=Henry&amp;lname=Ford&quot;); URL-服务器上的文件 open（）方法的url参数是服务器上文件的地址： xmlhttp.open(“GET”,”ajax_test.html”,true);该文件可以是任何类型的文件，比如txt或xml，或者服务器脚本文件，比如.asp或.php 异步ture或false？ AJAX指的是异步javaScript和XML。 XMLHttpRequest对象如果要用AJAX的话，其open（）方法的async参数必须设置为ture： xmlhttp.open(“GET”,”ajax_test.html”,true);位于web从业人员来叔发送异步请求是一个巨大的进步，很多在服务器执行的任务都相当费时。在AJAX出现之前这可能会导致应用程序挂起或停止。 通过AJAX，javaScript可以不用等待服务器的响应，而是： 在等待服务器响应时执行其他脚本。 当响应就绪后对其进行处理。 Async=ture 当使用async=ture时，请规定在响应处于onreadystatechange事件中的就绪状态时执行的函数： 12345678910xmlhttp.onreadystatechange=function()&#123; if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) &#123; document.getElementById(&quot;myDiv&quot;).innerHTML=xmlhttp.responseText; &#125;&#125;xmlhttp.open(&quot;GET&quot;,&quot;/try/ajax/ajax_info.txt&quot;,true);xmlhttp.send();Async=false 如果使用Async=false，请将open（）方法中的打三个参数设置为false： xmlhttp.open(“GET”,”test1.txt”,false);不推荐使用async=false，但是对一些小的请求也是可以的： 请记住，JavaScript 会等到服务器响应就绪才继续执行。如果服务器繁忙或缓慢，应用程序会挂起或停止。 注意：当您使用 async=false 时，请不要编写 onreadystatechange 函数 - 把代码放到 send() 语句后面即可。 AJAX-服务器响应 如需获取来自服务器的响应，请使用XMLHttpRequest对象的response Text或responseXML属性。 responseText属性 如果来自服务器的响应并非XML，请使用responseText属性。 responseText属性返回字符串形式的响应，因此可以这样使用： document.getElementById(“myDiv”).innerHTML=xmlhttp.responseText;responseXML属性 如果来自服务器的响应是XML，而且需要作为XML对象进行解析，使用responseXML属性 12345678xmlDoc=xmlhttp.responseXML;txt=&quot;&quot;;x=xmlDoc.getElementsByTagName(&quot;ARTIST&quot;);for (i=0;i&lt;x.length;i++)&#123; txt=txt + x[i].childNodes[0].nodeValue + &quot;&lt;br&gt;&quot;;&#125;document.getElementById(&quot;myDiv&quot;).innerHTML=txt; onreadystatechange事件 当请求被发送到服务器时，需要执行一些基于响应的任务。 每当readystate改变时，就会出发onreadystatechange事件。 ready state属性存有XMLHttpRequest的状态信息。 下面时XMLHttpRequest对象的三个重要属性： 在onreadystatechange事件中，我们规定当服务器响应已经做好被处理的准备时所执行的任务。 当readystate的值为4或状态码为200时，表示相应已就绪。 1234567xmlhttp.onreadystatechange=function()&#123; if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) &#123; document.getElementById(&quot;myDiv&quot;).innerHTML=xmlhttp.responseText; &#125;&#125; 注意：onreadystatechange 事件被触发 4 次（0 - 4）, 分别是： 0-1、1-2、2-3、3-4，对应着 readyState 的每个变化。 使用回调函数 回调函数是一种使用参数的形式传递给另一个函数的函数 如果你的网站上存在多个AJAX任务，那么你应该为创建XMLHttpRequest对象编写一个标准的函数，并为每个AJAX任务调用该函数。 该函数调用应包含URL已经发生onreadystatechange事件时执行的任务。 12345678910function myFunction()&#123; loadXMLDoc(&quot;/try/ajax/ajax_info.txt&quot;,function() &#123; if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) &#123; document.getElementById(&quot;myDiv&quot;).innerHTML=xmlhttp.responseText; &#125; &#125;);&#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://kirbey.github.io/hexoBlog/categories/前端/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://kirbey.github.io/hexoBlog/tags/javaScript/"}]},{"title":"封装一个函数","slug":"封装一个函数","date":"2019-10-08T14:29:43.000Z","updated":"2019-10-08T14:49:23.263Z","comments":true,"path":"2019/10/08/封装一个函数/","link":"","permalink":"https://kirbey.github.io/hexoBlog/2019/10/08/封装一个函数/","excerpt":"为了更方便的理解jQuery，我们来尝试自己封装一个函数使其拥有jQuery的功能，从而理解jQuery的原理。 首先我们写一个简单的HTML 接下来我们需要用到一个函数，来给HTML标签中的div元素添加一个class","text":"为了更方便的理解jQuery，我们来尝试自己封装一个函数使其拥有jQuery的功能，从而理解jQuery的原理。 首先我们写一个简单的HTML 接下来我们需要用到一个函数，来给HTML标签中的div元素添加一个class 注意在使用forEach() API的时候 对象必须是一个数组或伪数组。因此在给这个函数传递参数的时候需要加上[]. 用来添加text Content。 用来判断参数的属性接着封装这个函数 然后我们就可以尝试去调用它了 这里给几个简单的CSS属性 接着调用效果如下 至此我们自己完成了封装一个API并能够调用它 完整代码如下 1234567891011121314151617181920212223242526272829303132window.jQuery =function(node)&#123; let nodes = &#123;&#125; if (typeof node === &apos;string&apos;)&#123; let allSiblings = document.querySelectorAll(node) for (let i=0; i&lt;allSiblings.length; i++)&#123; nodes[i] = allSiblings[i] &#125; nodes.length = allSiblings.length &#125;else if (node instanceof Node)&#123; nodes = &#123; 0: node, length: 1 &#125; &#125; nodes.addClass = function(classes)&#123; classes.forEach((value) =&gt; &#123; for( let i=0; i&lt;nodes.length; i++)&#123; nodes[i].classList.add(value) &#125; &#125;) &#125; nodes.setText = function(text)&#123; for(let i=0; i&lt;nodes.length; i++)&#123; nodes[i].textContent = text &#125; &#125; return nodes&#125;window.$ = jQueryvar $div = $(&apos;div&apos;)$div.addClass([&apos;blue&apos;])$div.setText([&apos;hello world&apos;])","categories":[{"name":"前端","slug":"前端","permalink":"https://kirbey.github.io/hexoBlog/categories/前端/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://kirbey.github.io/hexoBlog/tags/javaScript/"}]},{"title":"Box Model","slug":"Box Model","date":"2019-10-08T12:54:31.000Z","updated":"2019-10-08T14:27:19.489Z","comments":true,"path":"2019/10/08/Box Model/","link":"","permalink":"https://kirbey.github.io/hexoBlog/2019/10/08/Box Model/","excerpt":"","text":"首先理解什么是盒模型： 网页可以看成是由许多个盒子通过不同的堆积方式组成的一个仓库，网页上的每个HTML元素都被浏览器看成是一个个矩形的盒子，这个盒子由元素的内容，填充，边框，边界组成。默认边框背景色透明，默认看不到盒子：（图一） Margin(外边距) - 清除边框外的区域，外边距是透明的。Border(边框) - 围绕在内边距和内容外的边框。Padding(内边距) - 清除内容周围的区域，内边距是透明的。Content(内容) - 盒子的内容，显示文本和图像。那么两种盒子模型分别是什么呢： 一、W3C的标准盒子模型：（图二） 在标准盒子模型中，width指的是content的宽度 二、IE盒子模型：（图三） 在IE盒子模型中width指的是content+padding+border这三个部分的宽度。 由于W3C盒模型适用于所有的浏览器，因此我们都默认使用W3C的盒模型，我们常见的就是确保了页面是按照W3C的盒模型渲染的。 使用box-sizing切换盒模型： box-sizing: content-box 这个是W3C盒子模型 box-sizing: border-box 这个是IE盒子模型 默认box-sizing的属性是content-box","categories":[{"name":"前端","slug":"前端","permalink":"https://kirbey.github.io/hexoBlog/categories/前端/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://kirbey.github.io/hexoBlog/tags/CSS/"}]},{"title":"什么是'闭包'","slug":"闭包","date":"2019-10-08T03:39:10.000Z","updated":"2019-10-08T12:48:22.352Z","comments":true,"path":"2019/10/08/闭包/","link":"","permalink":"https://kirbey.github.io/hexoBlog/2019/10/08/闭包/","excerpt":"","text":"闭包的概念非常简单：闭包就是能够读取其他函数内部变量的函数。 闭包不止作为一个优化代码的重要途经（可以帮助我们省去大量重复的代码，使整篇代码看起来清晰明朗）同时也具备两个重要功能：1、保护函数内的变量安全2、在内存中维持一个变量。要理解这两点的具体含义首先我们要理解变量的作用域：当你在一个函数内部声明变量（即局部变量）时一定要用 var ，否则实际是在申明一个全局变量。通常我们是不能在函数的作用域之外调取函数内的局部变量的，但某些特殊情况下需要我们这么做。这时我们需要在函数内部再定义一个函数。 123456789function f1()&#123; var n=999; function f2()&#123; alert(n); // 999 &#125; &#125; 在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1就是不可见的。 基于此我们不难理解第一点，由于局部变量只能被闭包调用从而保证了它的安全性。而之所以闭包可以在内存中维持一个变量是因为垃圾回收机制（garbage collection）。闭包可以使变量保持在被调用状态不会被回收。 根据这两点特性，也有两点注意事项：1、由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。2、闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。","categories":[{"name":"前端","slug":"前端","permalink":"https://kirbey.github.io/hexoBlog/categories/前端/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://kirbey.github.io/hexoBlog/tags/javaScript/"}]},{"title":"我的第一篇博客","slug":"我的第一篇博客","date":"2019-10-07T17:57:28.000Z","updated":"2019-10-07T17:58:51.953Z","comments":true,"path":"2019/10/08/我的第一篇博客/","link":"","permalink":"https://kirbey.github.io/hexoBlog/2019/10/08/我的第一篇博客/","excerpt":"","text":"","categories":[],"tags":[{"name":"这篇博客用来测试HEXO是否搭建并上传成功","slug":"这篇博客用来测试HEXO是否搭建并上传成功","permalink":"https://kirbey.github.io/hexoBlog/tags/这篇博客用来测试HEXO是否搭建并上传成功/"}]}]}