{"meta":{"title":"Kirbey's blog","subtitle":"自我学习的博客页面","description":null,"author":"kirbey","url":"https://kirbey.github.io/hexoBlog","root":"/hexoBlog/"},"pages":[{"title":"测试","date":"2019-10-07T17:31:33.000Z","updated":"2019-10-07T17:31:33.194Z","comments":true,"path":"测试/index.html","permalink":"https://kirbey.github.io/hexoBlog/测试/index.html","excerpt":"","text":""}],"posts":[{"title":"vuex","slug":"vuex","date":"2019-10-08T14:49:45.000Z","updated":"2019-10-08T14:57:52.290Z","comments":true,"path":"2019/10/08/vuex/","link":"","permalink":"https://kirbey.github.io/hexoBlog/2019/10/08/vuex/","excerpt":"Vuex是一个专门为Vue.js应用程序开发的状态管理模式。它采用集中式储存管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的状态发生变化。Vuex也集成到Vue的官方调试工具devtools extension，提供了诸如零配置的time-travel调试，状态快照导入导出等高级调试功能。 什么是“状态管理模式”？ 让我们从一个简单的Vue计数应用开始。 这个状态自管理应用包含一下几个部分： ·state，驱动应用的数据源； ·view，以声明方式将state映射到视图； ·action，相应在view上的用户输入导致的变化。 以下是一个表示“单项数据流”理念的简单示意：","text":"Vuex是一个专门为Vue.js应用程序开发的状态管理模式。它采用集中式储存管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的状态发生变化。Vuex也集成到Vue的官方调试工具devtools extension，提供了诸如零配置的time-travel调试，状态快照导入导出等高级调试功能。 什么是“状态管理模式”？ 让我们从一个简单的Vue计数应用开始。 这个状态自管理应用包含一下几个部分： ·state，驱动应用的数据源； ·view，以声明方式将state映射到视图； ·action，相应在view上的用户输入导致的变化。 以下是一个表示“单项数据流”理念的简单示意： 但是，当我们的组件遇到多个组件共享状态时，单向数据流的简洁性很容易被破坏： ·多个视图依赖于同一状态。 ·来自不同视图的行为需要变更同一状态。 对于问题一，传参的方式对于多层嵌套的组件将会非常繁琐，并且对于兄弟组件间的状态传递无能为力。 对于问题二，我们经常会采用父子组件直接引用或者通过事件来变更和同步状态的多份拷贝。以上的这些模式非常脆弱，通常会导致无法维护的代码。 因此，为什么我们不把组件的共享状态抽取出来，以一个全局单例模式管理呢？在这种模式下，我们的组件树构成了一个巨大的“视图”，不管在树的哪个位置，任何组件都能获取行为或触发状态。 通过定义和隔离状态管理中的各种概念并通过强制规则维持视图和状态间的独立性，我们的代码将会变得更结构化和易维护。 这就是Vuex背后的基本思想，借鉴了Flux，和Redux和Elm Architecture。与其他模式不同的是，Vuex是专门为Vue.js设计的状态管理库，以利用Vue.js的细粒度数据响应机制来进行高效的状态更新。 什么情况下我应该使用Vuex？ Vuex可以帮助我们管理共享状态，并附带了更多的概念和框架。着需要对短期和长期效益进行权衡。 如果你不打算开发大型单页应用，使用Vuex可能是繁琐冗余的。确实如此如果你的应用够简单，你最好不要使用Vuex。一个简单的store模式就足够你所需了。但是，如果你需要构建一个中大型单页应用，你可能会考虑如何更好地在组件外部管理状态，Vuex将会成为自然而然的选择。 安装 直接下载/CDN引用： https://unpkg.com/vuex​unpkg.com unpkg.com 以上链接会一直指向npm上发布的最新版本。你也可以通过这样的方式来指定版本。 在Vue之后引入Vuex会进行自动安装： 12345678&lt;script src=&quot;/path/to/vue.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;/path/to/vuex.js&quot;&gt;&lt;/script&gt;npmnpm install vuex --saveYarmyarn add vuex 在一个模块化的打包系统中，你必须通过Vue.use()来安装Vuex 1234import Vue from &apos;vue&apos;import Vuex from &apos;vuex&apos;Vue.use(Vuex) 当使用全局script标签引入Vuex时，不需要以上安装过程。 Promise Vuex依赖Promise。如果你支持的浏览器并没有实现Promise那么你可以使用一个 polyfill 的库，例如es6-promise。 你可以通过CDN将其引入： 1&lt;script src=&quot;https://cdn.jsdelivr.net/npm/es6-promise@4/dist/es6-promise.auto.js&quot;&gt;&lt;/script&gt; 然后window.Promise会自动可用。 如果你喜欢使用诸如npm和yarn等包管理器，可以按照下列方式执行安装： npm install es6-promise –save # npmyarn add es6-promise # Yarn或者更进一步，将下列代码添加到你使用Vuex之前的一个地方。 import ‘es6-promise/auto’自己构建 如果需要使用dev分支下的最新版本，您可以直接从Github上克隆代码并自己构建。 1234git clone https://github.com/vuejs/vuex.git node_modules/vuexcd node_modules/vuexnpm installnpm run build","categories":[{"name":"前端","slug":"前端","permalink":"https://kirbey.github.io/hexoBlog/categories/前端/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://kirbey.github.io/hexoBlog/tags/Vue/"}]},{"title":"封装一个函数","slug":"封装一个函数","date":"2019-10-08T14:29:43.000Z","updated":"2019-10-08T14:49:23.263Z","comments":true,"path":"2019/10/08/封装一个函数/","link":"","permalink":"https://kirbey.github.io/hexoBlog/2019/10/08/封装一个函数/","excerpt":"为了更方便的理解jQuery，我们来尝试自己封装一个函数使其拥有jQuery的功能，从而理解jQuery的原理。 首先我们写一个简单的HTML 接下来我们需要用到一个函数，来给HTML标签中的div元素添加一个class","text":"为了更方便的理解jQuery，我们来尝试自己封装一个函数使其拥有jQuery的功能，从而理解jQuery的原理。 首先我们写一个简单的HTML 接下来我们需要用到一个函数，来给HTML标签中的div元素添加一个class 注意在使用forEach() API的时候 对象必须是一个数组或伪数组。因此在给这个函数传递参数的时候需要加上[]. 用来添加text Content。 用来判断参数的属性接着封装这个函数 然后我们就可以尝试去调用它了 这里给几个简单的CSS属性 接着调用效果如下 至此我们自己完成了封装一个API并能够调用它 完整代码如下 1234567891011121314151617181920212223242526272829303132window.jQuery =function(node)&#123; let nodes = &#123;&#125; if (typeof node === &apos;string&apos;)&#123; let allSiblings = document.querySelectorAll(node) for (let i=0; i&lt;allSiblings.length; i++)&#123; nodes[i] = allSiblings[i] &#125; nodes.length = allSiblings.length &#125;else if (node instanceof Node)&#123; nodes = &#123; 0: node, length: 1 &#125; &#125; nodes.addClass = function(classes)&#123; classes.forEach((value) =&gt; &#123; for( let i=0; i&lt;nodes.length; i++)&#123; nodes[i].classList.add(value) &#125; &#125;) &#125; nodes.setText = function(text)&#123; for(let i=0; i&lt;nodes.length; i++)&#123; nodes[i].textContent = text &#125; &#125; return nodes&#125;window.$ = jQueryvar $div = $(&apos;div&apos;)$div.addClass([&apos;blue&apos;])$div.setText([&apos;hello world&apos;])","categories":[{"name":"前端","slug":"前端","permalink":"https://kirbey.github.io/hexoBlog/categories/前端/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://kirbey.github.io/hexoBlog/tags/javaScript/"}]},{"title":"Box Model","slug":"Box Model","date":"2019-10-08T12:54:31.000Z","updated":"2019-10-08T14:27:19.489Z","comments":true,"path":"2019/10/08/Box Model/","link":"","permalink":"https://kirbey.github.io/hexoBlog/2019/10/08/Box Model/","excerpt":"","text":"首先理解什么是盒模型： 网页可以看成是由许多个盒子通过不同的堆积方式组成的一个仓库，网页上的每个HTML元素都被浏览器看成是一个个矩形的盒子，这个盒子由元素的内容，填充，边框，边界组成。默认边框背景色透明，默认看不到盒子：（图一） Margin(外边距) - 清除边框外的区域，外边距是透明的。Border(边框) - 围绕在内边距和内容外的边框。Padding(内边距) - 清除内容周围的区域，内边距是透明的。Content(内容) - 盒子的内容，显示文本和图像。那么两种盒子模型分别是什么呢： 一、W3C的标准盒子模型：（图二） 在标准盒子模型中，width指的是content的宽度 二、IE盒子模型：（图三） 在IE盒子模型中width指的是content+padding+border这三个部分的宽度。 由于W3C盒模型适用于所有的浏览器，因此我们都默认使用W3C的盒模型，我们常见的就是确保了页面是按照W3C的盒模型渲染的。 使用box-sizing切换盒模型： box-sizing: content-box 这个是W3C盒子模型 box-sizing: border-box 这个是IE盒子模型 默认box-sizing的属性是content-box","categories":[{"name":"前端","slug":"前端","permalink":"https://kirbey.github.io/hexoBlog/categories/前端/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://kirbey.github.io/hexoBlog/tags/CSS/"}]},{"title":"什么是'闭包'","slug":"闭包","date":"2019-10-08T03:39:10.000Z","updated":"2019-10-08T12:48:22.352Z","comments":true,"path":"2019/10/08/闭包/","link":"","permalink":"https://kirbey.github.io/hexoBlog/2019/10/08/闭包/","excerpt":"","text":"闭包的概念非常简单：闭包就是能够读取其他函数内部变量的函数。 闭包不止作为一个优化代码的重要途经（可以帮助我们省去大量重复的代码，使整篇代码看起来清晰明朗）同时也具备两个重要功能：1、保护函数内的变量安全2、在内存中维持一个变量。要理解这两点的具体含义首先我们要理解变量的作用域：当你在一个函数内部声明变量（即局部变量）时一定要用 var ，否则实际是在申明一个全局变量。通常我们是不能在函数的作用域之外调取函数内的局部变量的，但某些特殊情况下需要我们这么做。这时我们需要在函数内部再定义一个函数。 123456789function f1()&#123; var n=999; function f2()&#123; alert(n); // 999 &#125; &#125; 在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1就是不可见的。 基于此我们不难理解第一点，由于局部变量只能被闭包调用从而保证了它的安全性。而之所以闭包可以在内存中维持一个变量是因为垃圾回收机制（garbage collection）。闭包可以使变量保持在被调用状态不会被回收。 根据这两点特性，也有两点注意事项：1、由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。2、闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。","categories":[{"name":"前端","slug":"前端","permalink":"https://kirbey.github.io/hexoBlog/categories/前端/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://kirbey.github.io/hexoBlog/tags/javaScript/"}]},{"title":"我的第一篇博客","slug":"我的第一篇博客","date":"2019-10-07T17:57:28.000Z","updated":"2019-10-07T17:58:51.953Z","comments":true,"path":"2019/10/08/我的第一篇博客/","link":"","permalink":"https://kirbey.github.io/hexoBlog/2019/10/08/我的第一篇博客/","excerpt":"","text":"","categories":[],"tags":[{"name":"这篇博客用来测试HEXO是否搭建并上传成功","slug":"这篇博客用来测试HEXO是否搭建并上传成功","permalink":"https://kirbey.github.io/hexoBlog/tags/这篇博客用来测试HEXO是否搭建并上传成功/"}]}]}